# Python Implementation of string decoding algorithm found in a new Dridex sample
"""
 void decodeStrings_1400132f0(longlong char_buffer,longlong enc_data,uint key_size)

{
  ulonglong index;
  
  if (key_size != 0) {
    index = 0;
    do {
      *(char *)(char_buffer + index) =
           *(char *)(enc_data + index) - (&key_byte_DAT_1400143d0)[index & 15];
      index = index + 1;
    } while (index != key_size);
  }
  return;
}
"""

def decrypt_data(enc_data, key):
    key_size = len(key)
    decrypted_data = bytearray()
    if key_size != 0:
        for index in range(len(enc_data)):
            char_buffer_value = (enc_data[index] - key[index % key_size]) % 256 # %256 fixes index out of bounds error 
            decrypted_data.append(char_buffer_value)
            res = decrypted_data.decode()
    return res
    
# could probably just make decrypt_data take a list of bytearrays but it works
key_bytes = b'\x9a\xec\x2f\x36\x37\x2c\x5b\x9c\xc1\x3a\x6e\xd8\xb7\x26\x26\x23'
# DAT_14001437b
enc_data1 = b'\x05\x51\xa1\xa4\x9c\x98\x8e\xce\xef\x9e\xda\x44\xb7'
# DAT_140014389
enc_data2 = b'\xe6\x50\xa1\x7d\x9c\xa0\xab\x0e\x30\x9d\xd3\x3c\x2c\x98\x8b\x64\xfe\x50\xa1\x9b\xaa\x9f\x5b'
# DAT_1400143a1
enc_data3 = b'\xf0\x55\xa1\xaa\xac\x8d\xc7\xdd\x2d\xa6\xdd\x3b\xb7'
# DAT_140014370
enc_data4 = b'\x08\x60\x93\xa2\xa3\x5a\xbf\x08\x2d\x3a'


decrypted_data1 = decrypt_data(enc_data1, key_bytes)
decrypted_data2 = decrypt_data(enc_data2, key_bytes)
decrypted_data3 = decrypt_data(enc_data3, key_bytes)
decrypted_data4 = decrypt_data(enc_data4, key_bytes)

print(decrypted_data1,decrypted_data2,decrypted_data3,decrypted_data4, sep='\n')
