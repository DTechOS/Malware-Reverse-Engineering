--------------------------------------------Dridex and API hashing-------------------------------------------------------
Dridex Is a banking trojan that first appeared in 2014, and has used API hashing since it's first appearence.
I'll start by giving an example of API hashing, then reverse engineer an old and new sample of Dridex,
so we can observe how Dridex has changed it's API hashing techniques over the years. 
Dridex has been used in campaigns in over 40 countries so im not that concerened with the associated groups. Mainly the techniques employed.
https://attack.mitre.org/software/S0384/
-------------------------------------------------------------------------------------------------------------------------

A simple example of API hashing in C
------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
// this is really not effective and causes hash collisions very easily, just learning for malware
// building a resolver function next

char api[] = "CreateThread"; // api name to hash


void hash_from_string()
{
    int len = strlen(api);
    unsigned int hash = 0x35; // random byte


    for (int i = 0; i < len; i++) {
        hash += (hash * 0xab10f29f + api[i]) & 0xffffff; //0xab10f29f = another random value, 0xffffff = masking
    }
    printf("%s: 0x00%x\n", api, hash);
}

int main()
{
    hash_from_string();

}
------------------------------------------------------------------------------------------------------------------------------
For the resolver function, assuming we have a fully built hash table with the hahed API names and their respective DLL modules, 
we would just iterate over the table and use the same alg to resolve them.
------------------------------------------------------------------------------------------------------------------------------

                           

--------------------------------Old Dridex----------------------------------

Sha256:  f9495e968f9a1610c0cf9383053e5b5696ecc85ca3ca2a338c24c7204cc93881 
Compilation Time: 9-19-2020
----------------------------------------------------------------------------

In this sample there only 2 imports, OutputDebugStringA and Sleep. The rest,
are resolved dynamically at runtime using API hashing.
---------------------------------------------------------------------------------------------------------------------------------
##Spotting APi hashing:

Looking at DLLEntryPoint We can immediately spot some interesting instructions.
It pushes 2 values to the stack, one being negative. It looks like the call to the function 6015C0 takes these 2 values as an argument.

DllEntryPoint:
call    sub_607980 <------ probably locates hashes from table or some kind of encryption
push    1DAACBB7h
push    0A1310F65h
call    sub_6015C0
---------------------------------------------------------------------------------------------------------------------------------

Observe the similar behaviour at this location, pushes 2 values to the stack, sub_6015C0 takes these as an argument.
Notice the 2nd argument to sub_6015C0 is the same as before "0A1310F65h" because it remains the same, This is most likely the DLL module, and 0A8D05ACBh is the API import.


If you track the XREF's to sub_6015C0 you can observe the same instructions multiple times. From this we can guess that sub_6015C0 is our resolver function. 
Notice on the other calls to our resolver function, call sub_607980. Our next goal is to Identify the hashing algorithm

Loc_5f9E31:
push    0A8D05ACBh
push    0A1310F65h
mov     byte_62B004, 0
call    sub_6015C0
-----------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------Identifying the Algorithm-------------------------------------------------

For this part I'll use ghidra for generating pseudo code. there might be some slight changes in naming convention from IDA 

In the pseudo code the 1st arg is acutally the DLL module and the 2nd is the win api.
In the fun_6015C0 there's a check on param1, then it calls another function which it looks like to loads the correct DLL module.

    Resolves API's
        |
        |
        v
FUN_6015C0(0xa1310f65,0x1daacbb7)
{

LAB_00601650:
  if (param_1 != 0xe5ab9b45) {
    iVar2 = FUN_00607564(); <--- retrieve DLL module
    uVar4 = extraout_ECX;
    if ((iVar2 == 0) &&
       (uVar3 = FUN_00606c50(param_1), uVar4 = extraout_ECX_00, (char)uVar3 != '\0')) {
      iVar2 = FUN_00607564();
      uVar4 = extraout_ECX_01;
    }



}

Uvar5 is assigned teh return value of FUN_61d620 then is xored with the key 0x38ba5c7b, since the return value is xored, this is most likely the function that hashes the API's

FUN_00607564:

    uVar5 = FUN_0061d620((int)local_98,uVar10); <--- Hashes the API imorts
    if (local_14 == (uVar5 ^ 0x38ba5c7b)) {     <----- Xor key
      iVar4 = puVar12[6];
      if (iVar4 == 0) {
        return 0;
      }
      if (DAT_0062b26c != '\0') {
        if (local_14 != 0x588ab3ea) {
          return iVar4;
        }


                                        
                                       








































