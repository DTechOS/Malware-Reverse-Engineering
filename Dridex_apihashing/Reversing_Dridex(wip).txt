--------------------------------------------Dridex and API hashing-------------------------------------------------------
# Dridex Is a banking trojan that first appeared in 2014, and has used API hashing since it's first appearence.
I'll start by giving an example of API hashing, then reverse engineer an old and new sample of Dridex,
so we can observe how Dridex has changed it's API hashing techniques over the years. 
Dridex has been used in campaigns in over 40 countries so im not that concerened with the associated groups. Mainly the techniques employed.
https://attack.mitre.org/software/S0384/
-------------------------------------------------------------------------------------------------------------------------

## A simple example of API hashing in C
------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
// this is really not effective and causes hash collisions very easily, just learning for malware
// building a resolver function next

char api[] = "CreateThread"; // api name to hash


void hash_from_string()
{
    int len = strlen(api);
    unsigned int hash = 0x35; // random byte


    for (int i = 0; i < len; i++) {
        hash += (hash * 0xab10f29f + api[i]) & 0xffffff; //0xab10f29f = another random value, 0xffffff = masking
    }
    printf("%s: 0x00%x\n", api, hash);
}

int main()
{
    hash_from_string();

}
------------------------------------------------------------------------------------------------------------------------------
## For the resolver function, assuming we have a fully built hash table with the hahed API names and their respective DLL modules, 
we would just iterate over the table and use the same alg to resolve them.
------------------------------------------------------------------------------------------------------------------------------

                           

--------------------------------Old Dridex----------------------------------

Sha256:  f9495e968f9a1610c0cf9383053e5b5696ecc85ca3ca2a338c24c7204cc93881 
Compilation Time: 9-19-2020
----------------------------------------------------------------------------

## In this sample there only 2 imports, OutputDebugStringA and Sleep. The rest,
are resolved dynamically at runtime using API hashing.
---------------------------------------------------------------------------------------------------------------------------------
##Spotting APi hashing:

## Looking at DLLEntryPoint We can immediately spot some interesting instructions.
It pushes 2 values to the stack, one being negative. It looks like the call to the function 6015C0 takes these 2 values as an argument.

DllEntryPoint:
call    sub_607980 
push    1DAACBB7h
push    0A1310F65h
call    sub_6015C0
---------------------------------------------------------------------------------------------------------------------------------

## Observe the similar behaviour at this location, pushes 2 values to the stack, sub_6015C0 takes these as an argument.
Notice the 2nd argument to sub_6015C0 is the same as before "0A1310F65h" because it remains the same, This is most likely the DLL module, and 0A8D05ACBh is the API import.


## If you track the XREF's to sub_6015C0 you can observe the same instructions multiple times. From this we can guess that sub_6015C0 is our resolver function. 
Notice on the other calls to our resolver function, call sub_607980. Our next goal is to Identify the hashing algorithm

Loc_5f9E31:
push    0A8D05ACBh
push    0A1310F65h
mov     byte_62B004, 0
call    sub_6015C0
-----------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------Identifying the Algorithm-------------------------------------------------

# For this part I'll use ghidra for generating pseudo code. there might be some slight changes in naming convention from IDA 

## In the pseudo code the 1st arg is acutally the DLL module and the 2nd is the win api.
In the fun_6015C0 there's a check on param1, then it calls another function which it looks like to loads the correct DLL module.

    Resolves API's
        |
        |
        v
FUN_6015C0(0xa1310f65,0x1daacbb7)
{

LAB_00601650:
  if (param_1 != 0xe5ab9b45) {
    iVar2 = FUN_00607564(); <--- retrieve DLL module
    uVar4 = extraout_ECX;
    if ((iVar2 == 0) &&
       (uVar3 = FUN_00606c50(param_1), uVar4 = extraout_ECX_00, (char)uVar3 != '\0')) {
      iVar2 = FUN_00607564();
      uVar4 = extraout_ECX_01;
    }



}

## Uvar5 is assigned the return value of FUN_61d620 then is xored with the key 0x38ba5c7b, 
since the return value is xored, this is most likely the function that hashes the API's

FUN_00607564:

    uVar5 = FUN_0061d620((int)local_98,uVar10); <--- Hashes the API imorts
    if (local_14 == (uVar5 ^ 0x38ba5c7b)) {     <----- Xor key
      iVar4 = puVar12[6];
      if (iVar4 == 0) {
        return 0;
      }
      if (DAT_0062b26c != '\0') {
        if (local_14 != 0x588ab3ea) {
          return iVar4;
        }
        
        Analyzing the function FUN_61d620 I found that the ALG used is CRC32
        
---------------------------------------------------------------------------------------------------


--------------------------------------------Resolving the API's-------------------------------------

## Information so far:
- FUN_6015C0 resolves the API's
- FUN_0061d620 Performs the hashing In crc32
- FUN_00607564 Retireves the needded DLL module
- crc32 hahes are xored with the key 0x38ba5c7b

## knowing this I created a quick script to test if it works
--------------------------------------------------------
import zlib
s = b'CreateThread'
# using zlib.crc32() method
t = zlib.crc32(s)

xor =  t ^ 0x38ba5c7b

print(hex(xor))
--------------------------------------------------------
Output: CreatThread: 0xa8d05acb

## We can see this same hash being pased to FUN_6015C0 in DLL_entry,
So we have the right alg. now we just need to resolve the rest of the hashes in a less manual way

Method 1. maybe use windbg? it can debug dlls
Method 2. Hashdb to collect hashes then use matching to resolve the plain text string
Method 3. github.com/embee-research this script might work
Method 4. Dumpulator to just call the function,
          we need to create a mini dump for this to work.
          
# Collected Api imports 
[
004fccc0
01b51bda
02a01082
05790ac4
06b2abf0
077be1f6
09217c72
0a1ee59b
0d5493f9
0e214cde
193a1678
1b316d6f
1b47f147
1be15feb
1daacbb7
1f55daa4
21d14ca0
24700f86
28bc3354
2a9e90cd
31e65fab
31fb9d90
336e58dc
34e877b5
35b39b2b
36e9be29
3ab94787
3b4caff7
41195991
42b05860
43bd89bd
4a4a4f27
4a4b4242
4c00b324
4d235f87
4faea65b
57325ee3
588ab3ea
58d59bc9
5df582e1
60a7ee2b
6182260d
642cc78f
643f303c
649746ec
69121530
692332e2
6a68465a
6ad451b6
6f4b2710
755128fe
77b7f7e2
78757b46
790989c4
7b0e3dd6
7be03c70
7c5744d4
80eeda84
813508bf
81c9e4a7
828ca066
82d274c4
863455c4
87208d61
8813e141
8883f185
8a156a0e
8bfccac9
90eb856d
91935d4e
93fae3f6
97abe05f
98bb8ab2
9955b552
996e050f
9cac62c7
9e00e4e7
9ef5e083
9f411d1e
a1310f65
a23ab9f2
a3873ddb
a65417fb
a6df3111
a8d05acb
a8f2638d
ac46ecbb
af477fe3
b5cdecc0
b7186560
b8153e9a
b8566b51
b949c062
b9986e69
bcd9ca71
c054dc97
c0b67de0
c19ea29c
c27df3b5
c3c81127
c4879567
c4d11e8a
c928f867
cedbd48c
cf43c481
d16c9225
d27f045a
d77db60f
d8cc7390
d9057e28
d90e9ce8
d93f3271
dda3415f
e091aae1
e10858ef
e1167828
e2aa12c0
e2acf446
e2d27ff4
e349ddce
e4098524
e541bc4f
e5ab9b45
e5ef1afa
e9fbf3a8
ea812079
ea98589f
eb3bbc5d
ed971b31
ef367bc4
f1c64384
f341891c
f3af54a7
f4530a69
f561ae8b
f5e9a9a6
f780a78b
f949e40d
f95c938e
f9b72199
fa4e6739
ff8becc4
]
 
          











                                        
                                       








































