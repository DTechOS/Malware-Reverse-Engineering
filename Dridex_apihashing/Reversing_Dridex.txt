--------------------------------------------Dridex and API hashing-------------------------------------------------------
Dridex Is a banking trojan that first appeared in 2014, and has used API hashing since it's first appearence.
I'll start by giving an example of API hashing, then reverse engineer an old and new sample of Dridex,
so we can observe how Dridex has changed it's API hashing techniques over the years. 
Dridex has been used in campaigns in over 40 countries so im not that concerened with the associated groups. Mainly the techniques employed.
https://attack.mitre.org/software/S0384/
-------------------------------------------------------------------------------------------------------------------------

A simple example of API hashing in C
------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
// this is really not effective and causes hash collisions very easily, just learning for malware
// building a resolver function next

char api[] = "CreateThread"; // api name to hash


void hash_from_string()
{
    int len = strlen(api);
    unsigned int hash = 0x35; // random byte


    for (int i = 0; i < len; i++) {
        hash += (hash * 0xab10f29f + api[i]) & 0xffffff; //0xab10f29f = another random value, 0xffffff = masking
    }
    printf("%s: 0x00%x\n", api, hash);
}

int main()
{
    hash_from_string();

}
------------------------------------------------------------------------------------------------------------------------------
For the resolver function, assuming we have a fully built hash table with the hahed API names and their respective DLL modules, 
we would just iterate over the table and use the same alg to resolve them.
------------------------------------------------------------------------------------------------------------------------------

                           

--------------------------------Old Dridex----------------------------------

 Sha256:  f9495e968f9a1610c0cf9383053e5b5696ecc85ca3ca2a338c24c7204cc93881 
Compilation Time: 9-19-2020
----------------------------------------------------------------------------

In this sample there only 2 imports, OutputDebugStringA and Sleep. The rest,
are resolved dynamically at runtime using API hashing.
---------------------------------------------------------------------------------------------------------------------------------
##Spotting APi hashing:

Looking at DLLEntryPoint We can immediately spot some interesting instructions.
It pushes 2 values to the stack, one being negative. It looks like the call to the function 6015C0 takes these 2 values as an argument.

DllEntryPoint:
call    sub_607980 <------ probably locates hashes from table or some kind of encryption
push    1DAACBB7h
push    0A1310F65h
call    sub_6015C0
---------------------------------------------------------------------------------------------------------------------------------

Observe the similar behaviour at this location, pushes 2 values to the stack, sub_6015C0 takes these as an argument.
Notice the 2nd argument to sub_6015C0 is the same as before "0A1310F65h" because it remains the same, This is most likely the DLL module, and 0A8D05ACBh is the API import. The function would look like, resolver(API_hash, DLL_mod_hash).


If you track the XREF's to sub_6015C0 you can observe the same instructions multiple times. From this we can guess that sub_6015C0 is our resolver function. 
Notice on the other calls to our resolver function, call sub_607980


Loc_5f9E31:
push    0A8D05ACBh
push    0A1310F65h
mov     byte_62B004, 0
call    sub_6015C0
-----------------------------------------------------------------------------------------------------------------------------------








































