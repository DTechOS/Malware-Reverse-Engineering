#include <iostream>
#include <vector>
#include <windows.h>
#include <cmath>
#include <chrono>

struct Vector {
    double x;
    double y;
};

// Calculate euclidean distance between two points
double calculateDistance(Vector& v1, Vector& v2) {
    double dx = v2.x - v1.x;
    double dy = v2.y - v1.y;
    return sqrt(dx * dx + dy * dy);
}

// Calculate the angle between two vectors
double calculateAngle(Vector& v1, Vector& v2) {
    double dotProduct = v1.x * v2.x + v1.y * v2.y;
    double magnitudeProduct = sqrt(v1.x * v1.x + v1.y * v1.y) * sqrt(v2.x * v2.x + v2.y * v2.y);

    if (magnitudeProduct == 0.0) {
        return 0.0;  // Avoid division by zero
    }

    return acos(dotProduct / magnitudeProduct) * (180.0 / 3.14159265358979323846);  // Convert radians to degrees
}

// Check if all preceeding positions are different
bool arePositionsDifferent(const std::vector<Vector>& positions) {
    for (size_t i = 0; i < positions.size() - 1; ++i) {
        if (positions[i].x == positions[i + 1].x && positions[i].y == positions[i + 1].y) {
            return false; 
        }
    }
    return true; 
}

int main() {
    while (true) {
        FLOAT controlValue = 45.0;
        std::vector<Vector> positions;
        BOOL detectHit = FALSE;
        POINT initialCursorPos;
        GetCursorPos(&initialCursorPos);

        POINT currentCursorPos;
        do {
            Sleep(300);
            GetCursorPos(&currentCursorPos);
        } while (currentCursorPos.x == initialCursorPos.x && currentCursorPos.y == initialCursorPos.y);

        // Capture next 5 cursor positions
        for (int i = 0; i < 5; i++) {
            Sleep(50);
            GetCursorPos(&currentCursorPos);

            Vector v;
            v.x = static_cast<double>(currentCursorPos.x);
            v.y = static_cast<double>(currentCursorPos.y);

            positions.push_back(v);
        }

        // Check if all consecutive positions are different
        if (!arePositionsDifferent(positions)) {
            std::cout << "Capturing new positions." << std::endl;
            continue; 
        }

        // Calculate pos between vectors P01, P12, and P23
        Vector p1 = { positions[1].x - positions[0].x, positions[1].y - positions[0].y };
        Vector p2 = { positions[2].x - positions[1].x, positions[2].y - positions[1].y };
        Vector p3 = { positions[3].x - positions[2].x, positions[3].y - positions[2].y };
        Vector p4 = { positions[4].x - positions[3].x, positions[4].y - positions[3].y };

       
        double angle1 = calculateAngle(p1, p2);
        double angle2 = calculateAngle(p2, p3);
        double angle3 = calculateAngle(p3, p4);

       
        std::cout << "Angle between P1 and P2: " << angle1 << " degrees" << std::endl;
        std::cout << "Angle between P2 and P3: " << angle2 << " degrees" << std::endl;
        std::cout << "Angle between p3 and p4 " << angle3 << " degress" << std::endl;

        // Check if angles are below the threshold
        if (angle1 && angle2 && angle3 <= controlValue) {

            std::cout << "human mouse behaviour detected, starting additional checks";
            detectHit = true;
            
            // Display message box (next malware stage would go here)
            
            // Not in original sample, using for testing puproses and will improve if used

            if (detectHit == true) 
            { 
                Sleep(10000); 
                detectHit = false;
                MessageBox(NULL, L"Human mouse behavior detected! This is an example payload", L"Sandbox Detection Test", MB_OK);
                break;

                
            }

           
        }

    }

    return 0;
}
